name: Repo Snapshot (Issues, bodies only)
on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  dump:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build bundles (about 10 files per issue)
        id: build
        run: |
          python3 - << 'PY'
          import os, json, textwrap, hashlib, math

          # File types to include (add as needed)
          exts = {
            '.js','.mjs','.cjs','.ts','.tsx','.jsx',
            '.html','.css','.json','.glsl','.frag','.vert'
          }
          skip_dirs = {'.git','node_modules','dist','build','.cache'}

          files = []
          for root, dirs, filenames in os.walk('.'):
            parts = set(root.split(os.sep))
            if parts & skip_dirs: 
              continue
            for name in filenames:
              _, ext = os.path.splitext(name.lower())
              if ext in exts:
                path = os.path.join(root, name)
                try:
                  with open(path, 'r', encoding='utf-8', errors='replace') as f:
                    content = f.read()
                  rel = path[2:] if path.startswith('./') else path
                  files.append((rel, content))
                except Exception:
                  pass

          files.sort()
          # Batch ~10 files per issue; also keep total body under ~60k chars
          bundles = []
          batch = []
          total = 0
          LIMIT = 60000
          MAX_PER = 10

          def fence(rel, content):
            lang = 'html' if rel.endswith('.html') else ('css' if rel.endswith('.css') else 'js')
            return f"### `{rel}`\n```{lang}\n{content}\n```\n"

          for rel, content in files:
            block = fence(rel, content)
            if len(batch) >= MAX_PER or total + len(block) > LIMIT:
              bundles.append("".join(batch))
              batch, total = [], 0
            batch.append(block)
            total += len(block)
          if batch:
            bundles.append("".join(batch))

          os.makedirs('snap_out', exist_ok=True)
          with open('snap_out/bundles.json','w',encoding='utf-8') as w:
            json.dump(bundles, w)
          print(f"::set-output name=count::{len(bundles)}")
          PY

      - name: Create/Update Snapshot Issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const bundles = JSON.parse(fs.readFileSync('snap_out/bundles.json','utf8'));
            const metaHeader = [
              `**Branch:** ${context.ref}`,
              `**Commit:** ${context.sha}`,
              `**Pusher:** ${context.actor}`,
              '',
              '_Auto-updated on push to `main`. Source is embedded below. No comments are used to avoid connector limits._',
              ''
            ].join('\n');

            // List existing snapshot issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,repo-snapshot',
              per_page: 100,
            });

            // Update existing ones first; create more if needed
            let idx = 0;
            for (const issue of issues.filter(i => i.title.startsWith('Repo Snapshot (bundle ')).sort((a,b)=>a.title.localeCompare(b.title))) {
              if (idx >= bundles.length) break;
              const body = metaHeader + bundles[idx];
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                title: `Repo Snapshot (bundle ${idx+1}/${bundles.length})`,
                body
              });
              idx++;
            }

            // Create remaining
            for (; idx < bundles.length; idx++) {
              const body = metaHeader + bundles[idx];
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Repo Snapshot (bundle ${idx+1}/${bundles.length})`,
                body,
                labels: ['automated','repo-snapshot']
              });
            }

            // Close extra older snapshot issues if any
            for (const issue of issues) {
              if (!issue.title.startsWith('Repo Snapshot (bundle ')) continue;
              const n = parseInt(issue.title.replace('Repo Snapshot (bundle ','').split('/')[0],10);
              if (!Number.isFinite(n) || n <= 0 || n > bundles.length) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
            }
